module FiniteDifference

using LinearAlgebra
using ProgressMeter
using ..BurgersEquation: burgers_ic, viscosity

export solveFiniteDifference

"""
    solveFiniteDifferences(N; dt=1e-3, T=1.0, nu=viscosity(), ic=burgers_ic, S=4.0)

Solves the 1D Burgers equation
    u_t + u u_x = nu u_xx
on the domain x in [-1,1] with u(+-1,t)=0 using a finite-difference method on a nonuniform grid.

The grid is generated by the coordinate transformation
    x = g(zeta) = {
        -1 + tanh(2S zeta)/tanh(S),     for zeta in [0,0.5)
        1 + tanh(2S (zeta-1))/tanh(S),  for zeta in [0.5,1]},
with stretching parameter S. This clusters points near the large gradient region around x = 0.

The time-stepping is done using three-point backward scheme (BDF2 with bootstrapping using BDF1).

Solution history is saved at times t = 0, 1/pi, 2/pi, …, T.

Arguments:
- N: Number of grid points

Keyword arguments (optional):
- dt: Time step.
- T: Duration to solve over.
- nu: Kinematic viscosity (defaults to BurgersEquation.viscosity()).
- ic: Initial condition (defaults to BurgersEquation.burgers_ic()).
- S: Stretching parameter for the grid (default = 4.0).

Output
- x: Spatial grid of length N.
- u_final: Final solution in real space (length N).
- times: Vector of time steps.
- history: Vector of solution snapshots at times t = n/pi, n=0,1,2,...

"""
function solveFiniteDifference(N::Int; dt=1e-3, T=1.0, nu=viscosity(), ic=burgers_ic, S=4.0)
        # Generate uniform zeta grid and transformed x grid
        zeta = range(0.0, 1.0, length=N)  # N points from 0 to 1 inclusive
        x = Array{Float64}(undef, N)  # Physical grid of length N
        @inbounds for j in eachindex(zeta)
            if zeta[j] >= 0.5
                x[j] = 1 + tanh(2S*(zeta[j] - 1)) / tanh(S)
            else
                x[j] = -1 + tanh(2S*zeta[j]) / tanh(S)
            end
        end
    
        # Apply initial condition
        u0 = [ic(xj) for xj in x]
    
        # Precompute grid metric and spacing for derivative formulas
        gp = similar(x) # g'(zeta) at each grid point                       
        @inbounds for j in eachindex(zeta)
            if zeta[j] >= 0.5
                gp[j] = (2S * sech(2S*(zeta[j] - 1))^2) / tanh(S)
            else
                gp[j] = (2S * sech(2S*zeta[j])^2) / tanh(S)
            end
        end

        # Compute nonuniform spacing in physical x (h_L and h_R for interior points)
        hL = similar(x);  hR = similar(x)
        @inbounds for i in 2:N-1
            hL[i] = x[i] - x[i-1]                        # left spacing
            hR[i] = x[i+1] - x[i]                        # right spacing
        end
    
        # Allocate arrays for time integration
        M = N - 2 # number of interior unknowns
        # Full solution arrays (including boundaries) at previous two steps and current
        u_old_full   = copy(u0)                     # u^{n-2}
        u_prev_full  = similar(u0)                 # u^{n-1}
        u_full       = similar(u0)                 # u^{n}
        # Interior view for convenience (index 1 corresponds to physical index 2, etc.)
        u_old  = @view u_old_full[2:N-1]
        u_prev = @view u_prev_full[2:N-1]
        u      = @view u_full[2:N-1]
    
        # Preallocate tridiagonal matrix coefficients and RHS vector
        d   = Vector{Float64}(undef, M)             # main diagonal
        sub = Vector{Float64}(undef, M-1)           # sub-diagonal (length m-1)
        sup = Vector{Float64}(undef, M-1)           # super-diagonal (length m-1)
        b   = Vector{Float64}(undef, M)             # RHS vector
    
        # Time integration setup
        times = collect(0.0:dt:T)                   # time points from 0 to T
        tcount = length(times)
        # Prepare history of snapshots at t = n*pi^{-1}
        history = Vector{Vector{Float64}}()
        push!(history, copy(u0))                         # store initial condition at t=0
    
        ## First step: Backward Euler (BDF1) for n=1
        # Assemble matrix A for: (I/dt + (u^0) D - nu * D2) * u^1 = (1/dt)*u^0 
        @inbounds for j in 1:M
            i = j + 1                              # physical index corresponding to interior j
            # Time term on diagonal:
            d[j] = 1/dt
            # Diffusion terms:
            d[j]      += 2*nu / (hR[i]*hL[i])            # contribution to diag from u_{xx}
            if j < M
                sup[j]  = - nu * (2 / ((x[i+1] - x[i-1]) * hR[i]))   # diff term to i+1 neighbor
            end
            if j > 1
                sub[j-1] = - nu * (2 / ((x[i+1] - x[i-1]) * hL[i]))  # diff term to i-1 neighbor
            end
            # Convection terms (linearized using u^0):
            # u^0_i * (u_x^1)_i ≈ u^0_i * (u^1_{i+1} - u^1_{i-1})/(2 deltazeta * g'_i)
            if j < M
                sup[j] += (u0[i]) / (2*(zeta[2]-zeta[1]) * gp[i])   # conv contribution to i+1 neighbor
            end
            if j > 1
                sub[j-1] += -(u0[i]) / (2*(zeta[2]-zeta[1]) * gp[i]) # conv contribution to i-1 neighbor
            end
        end
        # Assemble RHS for first step: b = (1/dt) * u^0 (interior part)
        @inbounds for j in 1:M
            b[j] = u0[j+1] / dt 
        end
        # Solve the tridiagonal system for u^1 interior
        A = Tridiagonal(sub, d, sup)
        u_prev[:] = A \ b
        # Apply Dirichlet BC at boundaries (u_full includes boundaries)
        u_prev_full[1] = 0.0
        u_prev_full[end] = 0.0
    
        if tcount > 1 && abs(mod(times[2], 1/pi)) < dt/2
            push!(history, copy(u_prev_full))
        end
    
        ## Subsequent steps: BDF2 for n = 2,3,..., nsteps
        for n_idx in 3:tcount   # times indices (n_idx corresponds to time step n_idx-1)
            # n_idx-1 is the current time step number in 0-based indexing (i.e., n for u^n)
            # Assemble matrix for BDF2: (3/(2dt) I + u^{n-1} D - nu D2) * u^n = ... 
            @inbounds for j in 1:M
                i = j + 1
                # Time term:
                d[j] = 3/(2*dt)
                # Diffusion terms:
                d[j] += 2*nu / (hR[i]*hL[i])
                if j < M
                    sup[j]  = - nu * (2 / ((x[i+1] - x[i-1]) * hR[i]))
                end
                if j > 1
                    sub[j-1] = - nu * (2 / ((x[i+1] - x[i-1]) * hL[i]))
                end
                # Linearized convection terms (coefficients from u_prev_full = u^{n-1}):
                if j < M
                    sup[j] += (u_prev_full[i]) / (2*(zeta[2]-zeta[1]) * gp[i])
                end
                if j > 1
                    sub[j-1] += -(u_prev_full[i]) / (2*(zeta[2]-zeta[1]) * gp[i])
                end
            end
            # RHS: (4/(2dt)) u^{n-1} - (1/(2dt)) u^{n-2}  = 2/dt * u_prev - (1/(2dt)) * u_old
            @inbounds for j in 1:M
                b[j] = 2/dt * u_prev_full[j+1] - 1/(2*dt) * u_old_full[j+1]
            end
            # Solve for u^n
            A = Tridiagonal(sub, d, sup)
            u[:] = A \ b
            u_full[1] = 0.0
            u_full[end] = 0.0
    
            # Rotate time-level arrays for next step
            u_old_full .= u_prev_full    # u^{n-2} <- u^{n-1}
            u_prev_full .= u_full        # u^{n-1} <- u^{n}
            # Save snapshot if time is multiple of 1/pi
            if abs(mod(times[n_idx], 1/pi)) < dt/2
                push!(history, copy(u_full))
            end
        end
    
        # Ensure final state is in history (if T not exactly an integer multiple of 1/pi)
        if abs(mod(T, 1/pi)) > dt/2
            push!(history, copy(u_full))
        end
    
        return x, u_full, times, history
    end
    
    end  # module FiniteDifference