module FiniteDifference

using LinearAlgebra
using ProgressMeter
using ..BurgersEquation: burgers_ic, viscosity, setup_time_grid

export solveFiniteDifference

"""
    solveFiniteDifferences(N; dt=1e-3, T=1.0, nu=viscosity(), ic=burgers_ic, S=4.0)

Solves the 1D Burgers equation
    u_t + u u_x = nu u_xx
on the domain x in [-1,1] with u(+-1,t)=0 using a finite-difference method on a nonuniform grid.

The grid is generated by the coordinate transformation
    x = g(zeta) = {
        -1 + tanh(2S zeta)/tanh(S),     for zeta in [0,0.5[
        1 + tanh(2S (zeta-1))/tanh(S),  for zeta in [0.5,1]},
with stretching parameter S. This clusters points near the large gradient region around x = 0.

The time-stepping is done using three-point backward scheme (BDF2 with bootstrapping using BDF1).

Arguments:
- N: Number of grid points

Keyword arguments:
- dt: Time step.
- T: Duration to solve over.
- dt_snapshot: Time step for storing snapshots (default = -1, only initial state).
- nu: Kinematic viscosity (defaults to BurgersEquation.viscosity()).
- ic: Initial condition (defaults to BurgersEquation.burgers_ic()).
- S: Stretching parameter for the grid (default = 4.0).

Output:
- x: Real-space grid of length N.
- u_final: Final solution in real space (length N).
- snapshot_times: Vector of time steps at which the solution was saved.
- snapshots: Vector of solution snapshots at times t = {n*dt_snapshot}, n=0,1,2,...

"""
function solveFiniteDifference(N::Int; dt=1e-3, T=1.0, dt_snapshot = -1, nu=viscosity(), ic=burgers_ic, S=4.0)
        # Generate uniform zeta grid and transformed x grid
        zeta = range(0.0, 1.0, length=N)  # N points from 0 to 1 inclusive
        x = Array{Float64}(undef, N)  # Physical grid of length N
        @inbounds for j in eachindex(zeta)
            if zeta[j] >= 0.5
                x[j] = 1 + tanh(2S*(zeta[j] - 1)) / tanh(S)
            else
                x[j] = -1 + tanh(2S*zeta[j]) / tanh(S)
            end
        end
    
        # Apply initial condition
        u0 = [ic(xj) for xj in x]

        # Setup time integration and snapshots
        times, to_snapshot, snapshot_time_steps, snapshot_times = setup_time_grid(dt, T, dt_snapshot)
        snapshots = Vector{Vector{Float64}}()
        push!(snapshots, copy(u0)) # store initial condition at t=0
    
        # Precompute grid metric and spacing for derivative formulas
        gp = similar(x) # g'(zeta) at each grid point                       
        @inbounds for j in eachindex(zeta)
            if zeta[j] >= 0.5
                gp[j] = (2S * sech(2S*(zeta[j] - 1))^2) / tanh(S)
            else
                gp[j] = (2S * sech(2S*zeta[j])^2) / tanh(S)
            end
        end

        # Hessian
        #gpp = similar(x) # g''(zeta) at each grid point
        #@inbounds for j in eachindex(zeta)
        #    if zeta[j] >= 0.5
        #        gpp[j] = 
        #    else
        #        gpp[j] = 
        #    end
        #end

        # Compute nonuniform spacing in physical x (h_L and h_R for interior points)
        hL = similar(x);  hR = similar(x)
        @inbounds for i in 2:N-1
            hL[i] = x[i] - x[i-1] # Left spacing
            hR[i] = x[i+1] - x[i] # Right spacing
        end
    
        # Allocate arrays for time integration
        M = N - 2 # number of interior unknowns
        # Full solution arrays (including boundaries) at previous two steps and current
        u_old_full   = copy(u0)     # u^{n-2}
        u_prev_full  = similar(u0)   # u^{n-1}
        u_full       = similar(u0)   # u^{n}
        # Interior view for convenience (index 1 corresponds to physical index 2, etc.)
        #u_old  = @view u_old_full[2:N-1] # not used
        u_prev = @view u_prev_full[2:N-1]
        u      = @view u_full[2:N-1]
    
        # Preallocate tridiagonal matrix coefficients and RHS vector
        d   = Vector{Float64}(undef, M)             # main diagonal
        sub = Vector{Float64}(undef, M-1)           # sub-diagonal (length m-1)
        sup = Vector{Float64}(undef, M-1)           # super-diagonal (length m-1)
        b   = Vector{Float64}(undef, M)             # RHS vector

        ## First step: Backward Euler (BDF1) for n=1
        # Assemble matrix A for: (I/dt + (u^0) D - nu * D2) * u^1 = (1/dt)*u^0 
        # Note to self:
        #   A is very similar for BDF1 and BDF2, except for the main diagonal.
        #   I could save some lines by reusing the same code for both, but I'm in a rush right now.
        #   It's also probably better to simply use an if statement in the main loop to single out the first step.
        @inbounds for j in 1:M
            i = j + 1 # Physical index corresponding to interior j
            # Time term on diagonal:
            d[j] = 1/dt
            # Diffusion terms:
            d[j]      += 2*nu / (hR[i]*hL[i]) # Contribution to diag from u_{xx}
            if j < M
                sup[j]  = - nu * (2 / ((x[i+1] - x[i-1]) * hR[i])) # Diff term to i+1 neighbor
            end
            if j > 1
                sub[j-1] = - nu * (2 / ((x[i+1] - x[i-1]) * hL[i])) # Diff term to i-1 neighbor
            end
            # Advection terms (linearized using u^0):
            # u^0_i * (u_x^1)_i ~ u^0_i * (u^1_{i+1} - u^1_{i-1})/(2 deltazeta * g'_i)
            if j < M
                sup[j] += (u0[i]) / (2*(zeta[2]-zeta[1]) * gp[i]) # Adv contribution to i+1 neighbor
            end
            if j > 1
                sub[j-1] += -(u0[i]) / (2*(zeta[2]-zeta[1]) * gp[i]) # Adv contribution to i-1 neighbor
            end
        end
        # Assemble RHS for first step: b = (1/dt) * u^0 (interior part)
        @inbounds for j in 1:M
            b[j] = u0[j+1] / dt 
        end
        # Solve the tridiagonal system for u^1 interior
        A = Tridiagonal(sub, d, sup)
        u_prev[:] = A \ b
        # Apply Dirichlet BC at boundaries (u_full includes boundaries)
        u_prev_full[1] = 0.0
        u_prev_full[end] = 0.0
    
        t_step = 1
        # Store solution snapshot if on a snapshot time step
        if to_snapshot 
            if t_step in snapshot_time_steps
                push!(snapshots, copy(u)) # Store the snapshot
            end
        end
    
        ## Subsequent steps: BDF2 for n = 2,3,..., nsteps
        for t_step in 2:length(times) # again, I should probably loop over the whole thing instead and single out the first step
            # Assemble matrix for BDF2: (3/(2dt) I + u^{n-1} D - nu D2) * u^n = ... 
            @inbounds for j in 1:M
                i = j + 1
                # Time term:
                d[j] = 3/(2*dt)
                # Diffusion terms:
                d[j] += 2*nu / (hR[i]*hL[i])
                if j < M
                    sup[j]  = - nu * (2 / ((x[i+1] - x[i-1]) * hR[i]))
                end
                if j > 1
                    sub[j-1] = - nu * (2 / ((x[i+1] - x[i-1]) * hL[i]))
                end
                # Linearized advection terms (coefficients from u_prev_full = u^{n-1}):
                if j < M
                    sup[j] += (u_prev_full[i]) / (2*(zeta[2]-zeta[1]) * gp[i])
                end
                if j > 1
                    sub[j-1] += -(u_prev_full[i]) / (2*(zeta[2]-zeta[1]) * gp[i])
                end
            end
            # RHS: (4/(2dt)) u^{n-1} - (1/(2dt)) u^{n-2}  = 2/dt * u_prev - (1/(2dt)) * u_old
            @inbounds for j in 1:M
                b[j] = 2/dt * u_prev_full[j+1] - 1/(2*dt) * u_old_full[j+1]
            end
            # Solve for u^n
            A = Tridiagonal(sub, d, sup)
            u[:] = A \ b
            u_full[1] = 0.0
            u_full[end] = 0.0
    
            # Rotate time-level arrays for next step
            u_old_full .= u_prev_full    # u^{n-2} <- u^{n-1}
            u_prev_full .= u_full        # u^{n-1} <- u^{n}
            # Store solution snapshot if on a snapshot time step
            if to_snapshot 
                if t_step in snapshot_time_steps
                    push!(snapshots, copy(u_full)) # Store the snapshot
                end
            end
        end
        
        return x, u_full, snapshot_times, snapshots
    end
    
    end  # module FiniteDifference