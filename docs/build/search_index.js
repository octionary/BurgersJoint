var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = BurgersJoint","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"This page documents all modules and functions in BurgersJoint.","category":"page"},{"location":"api/#BurgersEquation","page":"API reference","title":"BurgersEquation","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [BurgersJoint.BurgersEquation]","category":"page"},{"location":"api/#BurgersJoint.BurgersEquation.analytical_slope-Tuple{Any, Any}","page":"API reference","title":"BurgersJoint.BurgersEquation.analytical_slope","text":"analytical_slope(x, t; nu=viscosity(), n=50)\n\nComputes the analytical slope from the analytical solution using central differences.\n\n\n\n\n\n","category":"method"},{"location":"api/#BurgersJoint.BurgersEquation.analytical_solution-Tuple{Any, Any}","page":"API reference","title":"BurgersJoint.BurgersEquation.analytical_solution","text":"analytical_solution(x, t; nu=viscosity(), n=50)\n\nComputes the analytical solution u(xt)` of Burgers' equation using the convolution form from Cole's transformation and Hermite integration. This assumes initial condition u(x,0) = -sin(pi*x).\n\nThe solution is expressed as\n\nu(xt) = fracI_1(xt)I_2(xt),\n\nwhere\n\nI_1(xt) = -int_-infty^+infty sin(pi(x-eta)) f(x-eta) expleft(-fraceta^24 nu tright) mathrmdeta,\n\nI_2(xt) = int_-infty^+infty f(x-eta) expleft(-fraceta^24 nu tright) mathrmdeta.\n\nHere, f(y) = exp(-cos(pi y)(2pinu)). A change of variables eta = S    z with S = sqrt4 nu t is used so that\n\ndeta = S mathrmdz quad expleft(-fraceta^24nu tright) = exp(-z^2).\n\nHermite quadrature (with n nodes, default n = 50) is used to evaluate these integrals.\n\n\n\n\n\n","category":"method"},{"location":"api/#BurgersJoint.BurgersEquation.burgers_ic-Tuple{Any}","page":"API reference","title":"BurgersJoint.BurgersEquation.burgers_ic","text":"burgers_ic(x)\n\nDefault initial condition for Burgersâ€™ equation, matching the setup in Basdevant1986:\n\n``u(x, 0) = -\\sin(\\pi x)``.\n\n\n\n\n\n","category":"method"},{"location":"api/#BurgersJoint.BurgersEquation.f-Tuple{Any}","page":"API reference","title":"BurgersJoint.BurgersEquation.f","text":"f(y; nu=viscosity())\n\nDefine the function f(y) as given in Basdevant1986.\n\n\n\n\n\n","category":"method"},{"location":"api/#BurgersJoint.BurgersEquation.viscosity-Tuple{}","page":"API reference","title":"BurgersJoint.BurgersEquation.viscosity","text":"viscosity()\n\nReturns the kinematic viscosity used in Basdevant1986: nu = 1(100pi).\n\n\n\n\n\n","category":"method"},{"location":"api/#ChebyshevTau","page":"API reference","title":"ChebyshevTau","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [BurgersJoint.ChebyshevTau]","category":"page"},{"location":"api/#BurgersJoint.ChebyshevTau.solveChebyshevTau-Tuple{Any}","page":"API reference","title":"BurgersJoint.ChebyshevTau.solveChebyshevTau","text":"solveChebyshevTau(N; dt=1e-3, T=1.0, nu=viscosity(), ic=burgers_ic)\n\nSolves the 1D Burgers equation on t in [0, T], x in [-1, 1] using the Chebyshev-Tau spectral method  with the ABCN scheme: Adams-Bashforth for the advective term and Crank-Nicholson for the viscous term, as described in Basdevant et al. (1986). As Basdevant1986 omits many details, I have also consulted the notes on spectral methods by Prof. Herman Clerx. Chebyshev-Gauss-Lobatto collocation points are used  for the spatial grid.\n\nArguments:\n\nN: Number of grid points - 1 (I don't like this notation, but it's common in the literature).\n\nKeyword arguments:\n\ndt: Time step.\nT: Duration to solve over.\ndt_snapshot: Time step for storing snapshots (default = -1, only initial state).\nnu: Kinematic viscosity (defaults to BurgersEquation.viscosity()).\nic: Initial condition (defaults to BurgersEquation.burgers_ic()).\n\nOutput:\n\nx: Real-space grid of length N.\nu_final: Final solution in real space (length N).\nsnapshot_times: Vector of time steps at which the solution was saved.\nsnapshots: Vector of solution snapshots at times t = {n*dt_snapshot}, n=0,1,2,...\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteDifference","page":"API reference","title":"FiniteDifference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [BurgersJoint.FiniteDifference]","category":"page"},{"location":"api/#BurgersJoint.FiniteDifference.solveFiniteDifference-Tuple{Int64}","page":"API reference","title":"BurgersJoint.FiniteDifference.solveFiniteDifference","text":"solveFiniteDifferences(N; dt=1e-3, T=1.0, nu=viscosity(), ic=burgers_ic, S=4.0)\n\nSolves the 1D Burgers equation     ut + u ux = nu u_xx on the domain x in [-1,1] with u(+-1,t)=0 using a finite-difference method on a nonuniform grid.\n\nThe grid is generated by the coordinate transformation     x = g(zeta) = {         -1 + tanh(2S zeta)/tanh(S),     for zeta in [0,0.5[         1 + tanh(2S (zeta-1))/tanh(S),  for zeta in [0.5,1]}, with stretching parameter S. This clusters points near the large gradient region around x = 0.\n\nThe time-stepping is done using three-point backward scheme (BDF2 with bootstrapping using BDF1).\n\nArguments:\n\nN: Number of grid points\n\nKeyword arguments:\n\ndt: Time step.\nT: Duration to solve over.\ndt_snapshot: Time step for storing snapshots (default = -1, only initial state).\nnu: Kinematic viscosity (defaults to BurgersEquation.viscosity()).\nic: Initial condition (defaults to BurgersEquation.burgers_ic()).\nS: Stretching parameter for the grid (default = 4.0).\n\nOutput:\n\nx: Real-space grid of length N.\nu_final: Final solution in real space (length N).\nsnapshot_times: Vector of time steps at which the solution was saved.\nsnapshots: Vector of solution snapshots at times t = {n*dt_snapshot}, n=0,1,2,...\n\n\n\n\n\n","category":"method"},{"location":"api/#FourierSpectral","page":"API reference","title":"FourierSpectral","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [BurgersJoint.FourierSpectral]","category":"page"},{"location":"api/#BurgersJoint.FourierSpectral.solveFourierSpectral-Tuple{Int64}","page":"API reference","title":"BurgersJoint.FourierSpectral.solveFourierSpectral","text":"solveFourierSpectral(N; dt=1e-3, T=1.0, nu=viscosity(), ic=burgers_ic, dealias_factor=2/3)\n\nSolves the 1D Burgers equation on t in [0, T], x in [-1, 1] using Fourier methods (Galerkin or  pseudospectral). It is based on the method described in Basdevant et al. (1986) and uses their leapfrog-like scheme for time integration. \n\nArguments:\n\nN: Number of grid points (also number of Fourier modes before dealiasing).\n\nKeyword arguments:\n\ndt: Time step.\nT: Duration to solve over.\ndt_snapshot: Time step for storing snapshots (default = -1, only initial state).\nnu: Kinematic viscosity (defaults to BurgersEquation.viscosity()).\nic: Initial condition (defaults to BurgersEquation.burgers_ic()).\ndealias_factor: Factor for dealiasing\n2/3 corresponsd to 2/3-rule Fourier Galerkin (default, aliasing errors removed).\n1 corresponds to Fourier pseudospectral (aliasing errors will be present).\n\nOutput:\n\nx: Real-space grid of length N.\nu_final: Final solution in real space (length N).\nsnapshot_times: Vector of time steps at which the solution was saved.\nsnapshots: Vector of solution snapshots at times t = {j*dt_snapshot}, j=0,1,2,...\n\n\n\n\n\n","category":"method"},{"location":"api/#NeuralNetwork","page":"API reference","title":"NeuralNetwork","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [BurgersJoint.NeuralNetwork]","category":"page"},{"location":"api/#BurgersJoint.NeuralNetwork.solveNeuralNetwork-Tuple{Int64}","page":"API reference","title":"BurgersJoint.NeuralNetwork.solveNeuralNetwork","text":"solveNeuralNetwork(N::Int; dt=1e-2, T=1.0, nu=viscosity(), ic=burgers_ic)\n\nSolves the 1D Burgers equation on t in [0, T], x in [-1, 1] using a physics-informed neural network (PINN). If no trained model exists, it will call trainNeuralNetwork(N; dt=dt, T=T, nu=nu, ic=ic) first. The predicted solution is evaluated at a grid of N points in x and at times t = 0, 1/pi, 2/pi, ..., T.\n\nArguments:\n\nN: Number of grid points in the spatial domain.\n\nKeyword arguments (optional):\n\ndt: Time step for the training (default = 1e-2).\nT: Duration to solve over (default = 1.0).\nnu: Kinematic viscosity, only used for training (default = BurgersEquation.viscosity()).\nic: Initial condition, only used for training (default = BurgersEquation.burgers_ic()).\n\nOutput:\n\nx: Spatial grid of length N.\nu_final: Final solution in real space (length N).\nsnapshot_times: Vector of time steps at which the solution was evaluated.\nhistory: Vector of solution snapshots at times t = n/pi, n=0,1,2,...\n\n\n\n\n\n","category":"method"},{"location":"api/#BurgersJoint.NeuralNetwork.trainNeuralNetwork-Tuple{Int64}","page":"API reference","title":"BurgersJoint.NeuralNetwork.trainNeuralNetwork","text":"trainNeuralNetwork(N::Int; dt=1e-2, T=1.0, nu=viscosity(), ic=burgers_ic)\n\nTrain a PINN for the 1D Burgers equation on t in [0, T], x in [-1, 1]. Discretizes the domain with a time-step dt and a spatial-step dx = 2/(N-1). Stores the trained model in the global variable trainedModel.\n\n\n\n\n\n","category":"method"},{"location":"#BurgersJoint-Documentation","page":"Home","title":"BurgersJoint Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for BurgersJoint. This project provides various methods to solve the 1D Burgers equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial upartial t + u fracpartial upartial x = nu fracpartial^2 upartial x^2","category":"page"},{"location":"","page":"Home","title":"Home","text":"where ( u(t, x) ) is the velocity field, ( \\nu ) is the viscosity, and ( t ) and ( x ) are time and space variables, respectively. The domain is defined as ( t \\in [0, T] ) and ( x \\in [-1, 1] ) with initial conditions ( u(0, x) = -\\sin(\\pi x) ) and periodic boundary conditions.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BurgersJoint is a Julia-based project that compares Fourier Galerkin, Fourier pseudospectral, Chebyshev Tau, finite difference, and neural network methods for solving Burgersâ€™ equation.","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BurgersEquation: Defines the PDE, initial conditions, and analytical solutions.\nFourierSpectral: Implements the Fourier Galerkin solver.\nChebyshevTau: Implements the Chebyshev Tau solver.\nFiniteDifference: Implements the finite difference solver.\nNeuralNetwork: Implements the Physics-Informed Neural Network (PINN) solver.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using BurgersJoint\nx = range(-1, 1, length=100)\nt = 0.5\nu_analytical = BurgersEquation.analytical_solution.(x, t)","category":"page"}]
}
